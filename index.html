<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PDF Editor ‚Äî Enhanced Layout</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Modern, compact UI -->
  <link rel="stylesheet"
        href="/assets/ui.css?v=<?=filemtime($_SERVER['DOCUMENT_ROOT'].'/assets/ui.css')?>">

  <!-- Tesseract.js for OCR (loaded from CDN) -->
  <script src="https://unpkg.com/tesseract.js@v4.1.4/dist/tesseract.min.js" defer onerror="console.log('OCR: Tesseract.js not available')"></script>

  <!-- Enhanced sidebar layout for better PDF viewing -->
  <style>
    :root{
      --bg:#0b1220; --card:#111827; --text:#e5e7eb; --border:#1f2937;
      --sidebar-width:280px;
    }
    html,body{ margin:0; background:var(--bg); color:var(--text); height:100%;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,'Helvetica Neue',Arial,sans-serif;}
    
    /* Main layout: fixed header, sidebar + viewer */
    .main-layout{ display:flex; height:calc(100vh - 50px); }
    
    /* Left sidebar for tools */
    .sidebar{
      width:var(--sidebar-width); min-width:var(--sidebar-width);
      background:var(--card); border-right:1px solid var(--border);
      overflow-y:auto; padding:12px; display:flex; flex-direction:column; gap:12px;
    }
    .sidebar-section{
      background:#0f172a; border:1px solid var(--border); border-radius:10px; padding:10px;
    }
    .sidebar-section h4{ margin:0 0 8px; font-size:13px; color:#94a3b8; text-transform:uppercase; letter-spacing:0.5px; }
    .sidebar-section label{ display:flex; align-items:center; gap:6px; margin-bottom:6px; font-size:13px; }
    .sidebar-section select, .sidebar-section input[type="text"], .sidebar-section input[type="number"]{
      width:100%; background:#0b1220; color:var(--text); border:1px solid var(--border); border-radius:6px; padding:6px 8px; font-size:13px;
    }
    .sidebar-section input[type="color"]{ width:32px; height:24px; padding:0; border:none; cursor:pointer; }
    .sidebar-section input[type="checkbox"]{ width:16px; height:16px; accent-color:#3b82f6; }
    .sidebar-section button{ width:100%; margin-top:4px; }
    .sidebar-row{ display:flex; gap:6px; align-items:center; margin-bottom:6px; }
    .sidebar-row label{ flex:1; margin-bottom:0; }
    
    /* Viewer area (takes remaining space) */
    .viewer-area{
      flex:1; display:flex; flex-direction:column; overflow:hidden;
    }
    
    /* Top toolbar (file + quick actions) */
    .top-toolbar{
      background:var(--card); border-bottom:1px solid var(--border);
      padding:8px 12px; display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    }
    .top-toolbar .drop-zone-input{ display:flex; align-items:center; gap:8px; }
    
    /* Viewer shell (maximized) */
    #viewerShell{ flex:1; border:1px solid var(--border); border-radius:12px; background:#0e0e0e; padding:8px; position:relative; margin:8px; display:flex; flex-direction:column; }
    #scroller{ flex:1; position:relative; overflow:auto; background:#111; border-radius:8px; }
    #pageLayer{ position:relative; width:max-content; height:max-content; margin:auto; }
    #pdfCanvas{ display:block; background:#fff; border-radius:8px; }
    #overlayCanvas{ position:absolute; left:0; top:0; pointer-events:none; }
    
    /* Bottom status bar */
    .status-bar{
      padding:6px 12px; background:var(--card); border-top:1px solid var(--border);
      display:flex; align-items:center; gap:12px; font-size:12px; color:#94a3b8;
    }
    .status-bar .kbd{ padding:0 6px; border:1px solid var(--border); border-radius:6px; background:#0f172a; color:#cbd5e1; }
    
    /* Misc */
    .muted{ color:#94a3b8; font-size:13px; }
    .kbd{ padding:0 6px; border:1px solid var(--border); border-radius:6px; background:#0f172a; color:#cbd5e1; }
    .drop-zone.drag-over #viewerShell{ border:2px dashed #3b82f6; background:#0f172a; }
    #dropOverlay{ display:none; position:absolute; inset:0; background:rgba(59,130,246,0.15); border-radius:8px; z-index:100; align-items:center; justify-content:center; font-size:18px; color:#93c5fd; pointer-events:none; }
    .drag-over #dropOverlay{ display:flex; }
    
    /* Loading/Progress indicator */
    #loadingIndicator{ display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#1e293b; border:1px solid #3b82f6; border-radius:12px; padding:20px 32px; z-index:1000; color:#e5e7eb; font-size:16px; box-shadow:0 8px 32px rgba(0,0,0,0.5); }
    #loadingIndicator.visible{ display:flex; align-items:center; gap:12px; }
    .spinner{ width:24px; height:24px; border:3px solid #3b82f6; border-top-color:transparent; border-radius:50%; animation:spin 1s linear infinite; }
    @keyframes spin{ to{ transform:rotate(360deg); } }
    
    /* Toast messages */
    .error-toast{ position:fixed; bottom:24px; right:24px; background:#7f1d1d; border:1px solid #ef4444; color:#fecaca; padding:12px 20px; border-radius:10px; z-index:1001; max-width:400px; box-shadow:0 4px 16px rgba(0,0,0,0.4); animation:slideIn 0.3s ease; }
    .warning-toast{ position:fixed; bottom:24px; right:24px; background:#78350f; border:1px solid #f59e0b; color:#fef3c7; padding:12px 20px; border-radius:10px; z-index:1001; max-width:400px; box-shadow:0 4px 16px rgba(0,0,0,0.4); animation:slideIn 0.3s ease; }
    .success-toast{ position:fixed; bottom:24px; right:24px; background:#14532d; border:1px solid #22c55e; color:#bbf7d0; padding:12px 20px; border-radius:10px; z-index:1001; max-width:400px; box-shadow:0 4px 16px rgba(0,0,0,0.4); animation:slideIn 0.3s ease; }
    @keyframes slideIn{ from{ transform:translateX(100%); opacity:0; } to{ transform:translateX(0); opacity:1; } }
    
    /* OCR progress */
    #ocrProgress{ display:none; background:#1e293b; border:1px solid #3b82f6; border-radius:8px; padding:8px; margin-top:8px; }
    #ocrProgress.visible{ display:block; }
    #ocrProgress .progress-bar{ height:6px; background:#1e3a5f; border-radius:3px; overflow:hidden; }
    #ocrProgress .progress-fill{ height:100%; background:#3b82f6; width:0%; transition:width 0.2s; }
    #ocrProgress .progress-text{ font-size:11px; color:#94a3b8; margin-top:4px; }
    
    /* Sidebar toggle for mobile */
    .sidebar-toggle{ display:none; background:var(--card); border:1px solid var(--border); border-radius:8px; padding:8px 12px; cursor:pointer; color:var(--text); }
    @media (max-width: 900px){
      .sidebar{ position:absolute; left:0; top:0; height:100%; z-index:50; transform:translateX(-100%); transition:transform 0.3s; }
      .sidebar.open{ transform:translateX(0); }
      .sidebar-toggle{ display:block; }
    }
    
    /* Legacy support for bar classes (for addon compatibility) */
    .bar, .bar2, .bar3{ display:none; }
  </style>
</head>
<body>

<!-- Loading indicator -->
<div id="loadingIndicator"><div class="spinner"></div><span id="loadingText">Loading PDF...</span></div>

<header class="topnav">
  <div class="brand">PDF Editor</div>
  <nav>
    <a href="/tools/merge.html">Merge</a>
    <a href="/tools/split.html">Split</a>
    <a href="/tools/crop.html">Crop</a>
    <a href="/tools/convert.html">Convert</a>
    <a href="/export.html">Exports</a>
    <a href="/help.html">Help</a>  
  </nav>
</header>

<div class="main-layout drop-zone" id="dropZone">
  <!-- Left Sidebar: All tools -->
  <aside class="sidebar" id="sidebar">
    <!-- Tool Selection -->
    <div class="sidebar-section">
      <h4>üîß Tool</h4>
      <select id="tool">
        <option value="select">Select / Move / Resize</option>
        <option value="editText">Edit Text</option>
        <option value="redact">Redact</option>
        <option value="image">Place Image</option>
        <option value="watermark">Watermark</option>
        <option value="find">Find Text</option>
        <option value="ocr">OCR (Extract Text)</option>
      </select>
    </div>

    <!-- Text Settings -->
    <div class="sidebar-section" id="textSettings">
      <h4>‚úèÔ∏è Text</h4>
      <label>Font:
        <select id="fontFamily">
          <optgroup label="Standard">
            <option value="Helvetica">Helvetica (sans)</option>
            <option value="TimesRoman">Times (serif)</option>
            <option value="Courier">Courier (mono)</option>
          </optgroup>
          <optgroup label="Google Fonts (Bundled)">
            <option value="Roboto">Roboto</option>
            <option value="Roboto-Bold">Roboto Bold</option>
            <option value="Roboto-Italic">Roboto Italic</option>
            <option value="OpenSans">Open Sans</option>
            <option value="OpenSans-Bold">Open Sans Bold</option>
            <option value="OpenSans-Italic">Open Sans Italic</option>
            <option value="Lato">Lato</option>
            <option value="Lato-Bold">Lato Bold</option>
            <option value="Lato-Italic">Lato Italic</option>
            <option value="Merriweather">Merriweather (serif)</option>
            <option value="Merriweather-Bold">Merriweather Bold</option>
            <option value="SourceSansPro">Source Sans Pro</option>
            <option value="SourceSansPro-Bold">Source Sans Pro Bold</option>
            <option value="SourceCodePro">Source Code Pro (mono)</option>
            <option value="SourceCodePro-Bold">Source Code Pro Bold</option>
          </optgroup>
          <optgroup label="Custom">
            <option value="Custom">Upload TTF/OTF...</option>
          </optgroup>
        </select>
      </label>
      <input id="customFont" type="file" accept=".ttf,.otf,.ttc,.otc" style="display:none" />
      <div class="sidebar-row">
        <label>Size: <input id="fontSize" type="number" min="6" max="120" step="1" value="12" style="width:60px" /></label>
        <label>Align:
          <select id="textAlign" style="width:70px">
            <option value="left">Left</option>
            <option value="center">Center</option>
            <option value="right">Right</option>
          </select>
        </label>
      </div>
      <div class="sidebar-row">
        <label><input id="bold" type="checkbox"> Bold</label>
        <label><input id="italic" type="checkbox"> Italic</label>
      </div>
      <input id="textValue" type="text" placeholder="Enter text‚Ä¶" />
      <div class="sidebar-row" style="margin-top:6px">
        <label>Text: <input id="textColor" type="color" value="#000000" /></label>
        <label>Cover: <input id="paintColor" type="color" value="#ffffff" /></label>
      </div>
    </div>

    <!-- Redact Settings -->
    <div class="sidebar-section" id="redactSettings">
      <h4>üîí Redact</h4>
      <label>Color: <input id="redactColor" type="color" value="#000000" /></label>
    </div>

    <!-- Image Settings -->
    <div class="sidebar-section" id="imageSettings">
      <h4>üñºÔ∏è Image</h4>
      <input id="imgFile" type="file" accept="image/*" />
    </div>

    <!-- OCR Settings -->
    <div class="sidebar-section" id="ocrSettings">
      <h4>üìù OCR</h4>
      <label>Language:
        <select id="ocrLang">
          <option value="eng">English</option>
          <option value="fra">French</option>
          <option value="deu">German</option>
          <option value="spa">Spanish</option>
          <option value="ita">Italian</option>
          <option value="por">Portuguese</option>
          <option value="nld">Dutch</option>
          <option value="pol">Polish</option>
          <option value="rus">Russian</option>
          <option value="jpn">Japanese</option>
          <option value="chi_sim">Chinese (Simplified)</option>
          <option value="ara">Arabic</option>
        </select>
      </label>
      <button id="ocrPage" class="btn-primary">OCR Current Page</button>
      <button id="ocrSelection">OCR Selection</button>
      <div id="ocrProgress">
        <div class="progress-bar"><div class="progress-fill" id="ocrProgressFill"></div></div>
        <div class="progress-text" id="ocrProgressText">Initializing...</div>
      </div>
    </div>

    <!-- Find Settings -->
    <div class="sidebar-section" id="findSettings">
      <h4>üîç Find</h4>
      <input id="findInput" type="text" placeholder="Search text‚Ä¶" />
      <button id="findNext">Find Next</button>
      <span id="findCount" class="muted"></span>
    </div>

    <!-- Zoom & View -->
    <div class="sidebar-section">
      <h4>üîé View</h4>
      <div class="sidebar-row">
        <button id="zoomOut" style="width:auto;padding:6px 12px">‚àí</button>
        <span id="zoomPct" class="chip" style="flex:1;text-align:center">100%</span>
        <button id="zoomIn" style="width:auto;padding:6px 12px">+</button>
      </div>
      <button id="zoomReset">Reset Zoom</button>
      <div class="sidebar-row" style="margin-top:8px">
        <label><input type="checkbox" id="snap"> Snap</label>
        <label><input type="checkbox" id="showGrid"> Grid</label>
      </div>
      <label>Grid size: <input id="gridSize" type="number" min="2" max="64" step="1" value="8" style="width:60px" /></label>
    </div>

    <!-- Rotation -->
    <div class="sidebar-section">
      <h4>üîÑ Rotate</h4>
      <div class="sidebar-row">
        <button id="rotL" class="btn-amber" style="flex:1" title="Rotate item -90¬∞">‚ü≤ Item</button>
        <button id="rotR" class="btn-amber" style="flex:1" title="Rotate item +90¬∞">‚ü≥ Item</button>
      </div>
      <div class="sidebar-row">
        <button id="pageRotL" class="btn-amber" style="flex:1" title="Rotate page -90¬∞">‚ü≤ Page</button>
        <button id="pageRotR" class="btn-amber" style="flex:1" title="Rotate page +90¬∞">‚ü≥ Page</button>
      </div>
    </div>

    <!-- Selection Actions -->
    <div class="sidebar-section">
      <h4>‚úÇÔ∏è Selection</h4>
      <div class="sidebar-row">
        <button id="undo" style="flex:1">‚ü≤ Undo</button>
        <button id="redo" style="flex:1">‚ü≥ Redo</button>
      </div>
      <div class="sidebar-row">
        <button id="duplicate" style="flex:1">‚ßâ Copy</button>
        <button id="delete" class="danger" style="flex:1">üóë Delete</button>
      </div>
    </div>

    <!-- Page Operations -->
    <div class="sidebar-section">
      <h4>üìÑ Page</h4>
      <div class="sidebar-row">
        <button id="pageInsertBefore" style="flex:1">+ Before</button>
        <button id="pageInsertAfter" style="flex:1">+ After</button>
      </div>
      <div class="sidebar-row">
        <button id="pageDuplicate" style="flex:1">Duplicate</button>
        <button id="pageDelete" class="danger" style="flex:1">Delete</button>
      </div>
      <div class="sidebar-row">
        <button id="pageUp" style="flex:1">‚ñ≤ Move Up</button>
        <button id="pageDown" style="flex:1">‚ñº Move Down</button>
      </div>
    </div>

    <!-- Save/Export -->
    <div class="sidebar-section">
      <h4>üíæ Save</h4>
      <input id="versionName" type="text" placeholder="Version name (optional)" />
      <label>Keep versions: <input id="keepN" type="number" min="1" max="20" value="5" style="width:60px" /></label>
      <button id="apply" class="btn-primary">Apply Changes</button>
      <button id="download" class="btn-primary">Download PDF</button>
      <button id="save">Save to Server</button>
    </div>
  </aside>

  <!-- Viewer Area -->
  <main class="viewer-area">
    <!-- Top toolbar: file input + page navigation -->
    <div class="top-toolbar">
      <button class="sidebar-toggle" id="sidebarToggle">‚ò∞ Tools</button>
      <div class="drop-zone-input">
        <input id="file" type="file" accept="application/pdf" />
        <span class="muted">or drag & drop PDF</span>
      </div>
      <span id="pageInfo" style="margin-left:auto">‚Äî</span>
    </div>

    <!-- Viewer Shell -->
    <div id="viewerShell">
      <div id="dropOverlay">üìÑ Drop PDF file here</div>
      <div id="scroller">
        <div id="pageLayer">
          <canvas id="pdfCanvas"></canvas>
          <canvas id="overlayCanvas"></canvas>
        </div>
      </div>
    </div>

    <!-- Status bar -->
    <div class="status-bar">
      <span><span class="kbd">Space</span> pan</span>
      <span><span class="kbd">Ctrl+Wheel</span> zoom</span>
      <span><span class="kbd">Alt+R</span> rotate item</span>
      <span><span class="kbd">Alt+P</span> rotate page</span>
      <span><span class="kbd">G</span> grid</span>
      <span><span class="kbd">S</span> snap</span>
    </div>
  </main>
</div>

<!-- PDF.js (self-hosted UMD) -->
<script src="/vendor/pdf.min.js"></script>
<script> pdfjsLib.GlobalWorkerOptions.workerSrc = "/vendor/pdf.worker.min.js"; </script>

<!-- pdf-lib (self-hosted) -->
<script src="/vendor/pdf-lib.min.js"></script>

<!-- App scripts -->
<script>
/* ====== Helpers / constants ====== */
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const deepClone = (o)=>JSON.parse(JSON.stringify(o));
const dpr = ()=>Math.max(1, window.devicePixelRatio||1);
const rad = (deg)=>deg*Math.PI/180;
const GUIDE_EPS = 5;   // px tolerance for smart guides

/* ====== DOM refs ====== */
function q(sel){ return document.querySelector(sel); }
const el = {
  file: q('#file'), tool: q('#tool'),
  fontFamily: q('#fontFamily'), fontSize: q('#fontSize'), textAlign: q('#textAlign'),
  bold: q('#bold'), italic: q('#italic'), customFont: q('#customFont'),
  textValue: q('#textValue'), textColor: q('#textColor'), paintColor: q('#paintColor'), redactColor: q('#redactColor'),
  findInput: q('#findInput'), findNext: q('#findNext'), findCount: q('#findCount'),
  imgFile: q('#imgFile'),

  pdfCanvas: q('#pdfCanvas'), overlay: q('#overlayCanvas'), pageInfo: q('#pageInfo'),
  undo: q('#undo'), redo: q('#redo'), duplicate:q('#duplicate'), del:q('#delete'),
  apply: q('#apply'), save: q('#save'), download: q('#download'),
  zoomIn:q('#zoomIn'), zoomOut:q('#zoomOut'), zoomReset:q('#zoomReset'), zoomPct:q('#zoomPct'),
  scroller:q('#scroller'), pageLayer:q('#pageLayer'),
  pageInsertBefore:q('#pageInsertBefore'), pageInsertAfter:q('#pageInsertAfter'), pageDuplicate:q('#pageDuplicate'),
  pageDelete:q('#pageDelete'), pageUp:q('#pageUp'), pageDown:q('#pageDown'),
  snap:q('#snap'), gridSize:q('#gridSize'), showGrid:q('#showGrid'),
  versionName:q('#versionName'), keepN:q('#keepN'),
  rotL:q('#rotL'), rotR:q('#rotR'),
  pageRotL:q('#pageRotL'), pageRotR:q('#pageRotR')
};
const pdfCtx = el.pdfCanvas.getContext('2d');
const overlayCtx = el.overlay.getContext('2d');

/* ====== App state ====== */
let pdfBytes = null;
let pdfDocWriter = null;      // pdf-lib
let pdfDocRender = null;      // PDF.js
let viewport = null;          // PDF.js viewport
let currentPageIndex = 0;
let pageCount = 0;
let zoom = 1;

// NEW: per-page visual rotation offsets (0/90/180/270)
let pageRotDelta = [];

let edits = [];               // staged items: {id,type,page,rectCss:{x,y,w,h},rot, ...}
let nextId = 1;
let selectedIds = [];

let dragMode = null;          // 'move'|'resize'|'rotate'|null
let dragStart = null;         // {x,y} CSS
let startRects = null;        // [{id,rect,rot}]
let resizeHandle = null;
let groupBoxAtStart = null;

let toolDragging = false;     // creating new item
let toolDragStart = null;

let undoStack = [];
let redoStack = [];

let settings = { snap:false, grid:8, showGrid:false };

let customFontBytes = null;   // uploaded TTF/OTF bytes (Uint8Array)
let customFontEmbedded = null;

let findRuns = [];            // [{bboxCss:[x,y,w,h], text}]
let findIndex = -1;

/* ====== Loading & rendering ====== */
async function loadBoth(arrayBuffer){
  pdfBytes = arrayBuffer;
  pdfDocWriter = await PDFLib.PDFDocument.load(pdfBytes);
  pdfDocRender = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
  pageCount = pdfDocRender.numPages;
  currentPageIndex = clamp(currentPageIndex, 0, pageCount-1);

  // init page rotation deltas
  pageRotDelta = new Array(pageCount).fill(0);

  await renderPage(currentPageIndex, true);
}

async function renderPage(index, resetZoom=false){
  const page = await pdfDocRender.getPage(index+1);
  const containerW = Math.min(1100, el.scroller.clientWidth - 24 || 1100);
  const baseViewport = page.getViewport({ scale:1 });
  if (resetZoom) zoom = 1;

  const baseRot = page.rotate || 0; // include intrinsic rotation
  const extraRot = ((pageRotDelta[index] || 0) % 360 + 360) % 360;

  viewport = page.getViewport({
    scale: (containerW / baseViewport.width) * zoom * dpr(),
    rotation: (baseRot + extraRot) % 360
  });

  // size canvases
  el.pdfCanvas.width = Math.floor(viewport.width);
  el.pdfCanvas.height = Math.floor(viewport.height);
  el.pdfCanvas.style.width = Math.floor(viewport.width / dpr()) + 'px';
  el.pdfCanvas.style.height = Math.floor(viewport.height / dpr()) + 'px';

  el.overlay.width = el.pdfCanvas.width;
  el.overlay.height = el.pdfCanvas.height;
  el.overlay.style.width = el.pdfCanvas.style.width;
  el.overlay.style.height = el.pdfCanvas.style.height;

  el.pageLayer.style.width = el.pdfCanvas.style.width;
  el.pageLayer.style.height = el.pdfCanvas.style.height;

  // render base page
  overlayCtx.clearRect(0,0,el.overlay.width, el.overlay.height);
  await page.render({ canvasContext: pdfCtx, viewport }).promise;

  // extract text runs for find/assist
  await extractTextRuns(page);

  // draw overlay (items / grid)
  drawOverlay();

  // UI bits
  el.pageInfo.textContent = `Page ${index+1} / ${pageCount}`;
  el.zoomPct.textContent = Math.round(zoom*100) + '%';
}
</script>

<script>
/* ====== Text runs (find/replace assist) ====== */
async function extractTextRuns(page){
  findRuns = [];
  const tc = await page.getTextContent();
  for (const item of tc.items){
    const t = item.transform; // [a,b,c,d,e,f]; e=x, f=y
    const w = item.width, h = item.height;
    const x = t[4], y = t[5];
    const x2 = x + w, y2 = y - h;

    const p1 = pdfToCssPoint(x, y);
    const p2 = pdfToCssPoint(x2, y2);
    const r = normalizeCssRect({x:p1.x, y:p1.y}, {x:p2.x, y:p2.y});

    if (r.w>0 && r.h>0) findRuns.push({ bboxCss:[r.x,r.y,r.w,r.h], text:item.str });
  }
}

/* ====== Coordinate helpers ====== */
function pdfToCssPoint(pdfX, pdfY){
  const [devX, devY] = viewport.convertToViewportPoint(pdfX, pdfY);
  return { x: devX/dpr(), y: devY/dpr() };
}
function cssToPdf(ptCss){
  const dev = { x: ptCss.x*dpr(), y: ptCss.y*dpr() };
  const [pdfX, pdfY] = viewport.convertToPdfPoint(dev.x, dev.y);
  return { x: pdfX, y: pdfY };
}
function cssRectToPdf(r){
  const tl = cssToPdf({x:r.x, y:r.y});
  const br = cssToPdf({x:r.x+r.w, y:r.y+r.h});
  return { x:tl.x, y:br.y, w:br.x-tl.x, h:tl.y-br.y };
}
function normalizeCssRect(a,b){
  const x1 = Math.min(a.x,b.x), y1 = Math.min(a.y,b.y);
  const x2 = Math.max(a.x,b.x), y2 = Math.max(a.y,b.y);
  return {x:x1, y:y1, w:x2-x1, h:y2-y1};
}
function toDev(r){ return { x:Math.round(r.x*dpr()), y:Math.round(r.y*dpr()), w:Math.round(r.w*dpr()), h:Math.round(r.h*dpr()) }; }

/* ====== Grid & guides ====== */
function drawGrid(){
  if (!settings.showGrid) return;
  const step = settings.grid*dpr();
  overlayCtx.save();
  overlayCtx.beginPath();
  overlayCtx.lineWidth = 1;
  overlayCtx.strokeStyle = "rgba(148,163,184,0.25)";
  for (let x=0; x<=el.overlay.width; x+=step){ overlayCtx.moveTo(x+0.5,0); overlayCtx.lineTo(x+0.5, el.overlay.height); }
  for (let y=0; y<=el.overlay.height; y+=step){ overlayCtx.moveTo(0,y+0.5); overlayCtx.lineTo(el.overlay.width,y+0.5); }
  overlayCtx.stroke(); overlayCtx.restore();
}
function snapVal(v){ return Math.round(v/settings.grid)*settings.grid; }
function snapRect(r){
  if (!settings.snap) return r;
  return { x:snapVal(r.x), y:snapVal(r.y), w:Math.max(settings.grid,snapVal(r.w)), h:Math.max(settings.grid,snapVal(r.h)) };
}
function computeGuides(movingIds){
  const lines = [];
  const pageW = parseFloat(el.pdfCanvas.style.width), pageH = parseFloat(el.pdfCanvas.style.height);
  lines.push({type:'v', pos:0},{type:'v', pos:pageW/2},{type:'v', pos:pageW});
  lines.push({type:'h', pos:0},{type:'h', pos:pageH/2},{type:'h', pos:pageH});
  for (const it of edits){
    if (it.page!==currentPageIndex) continue;
    if (movingIds.includes(it.id)) continue;
    const r = it.rectCss;
    lines.push({type:'v', pos:r.x},{type:'v', pos:r.x+r.w},{type:'v', pos:r.x+r.w/2});
    lines.push({type:'h', pos:r.y},{type:'h', pos:r.y+r.h},{type:'h', pos:r.y+r.h/2});
  }
  return lines;
}
function snapToGuides(rect, guides){
  const v = [{name:'left', val:rect.x},{name:'center', val:rect.x+rect.w/2},{name:'right', val:rect.x+rect.w}];
  const h = [{name:'top', val:rect.y},{name:'middle', val:rect.y+rect.h/2},{name:'bottom', val:rect.y+rect.h}];
  let dx=0, dy=0, hitV=null, hitH=null;
  for (const g of guides){
    if (g.type==='v'){
      for (const e of v){ if (Math.abs(e.val+dx - g.pos) <= GUIDE_EPS){ dx += (g.pos - (e.val+dx)); hitV = g.pos; } }
    } else {
      for (const e of h){ if (Math.abs(e.val+dy - g.pos) <= GUIDE_EPS){ dy += (g.pos - (e.val+dy)); hitH = g.pos; } }
    }
  }
  return { rect: { x:rect.x+dx, y:rect.y+dy, w:rect.w, h:rect.h }, hitV, hitH };
}
function drawGuideLines(hitV, hitH){
  overlayCtx.save();
  overlayCtx.lineWidth = 1*dpr();
  overlayCtx.setLineDash([6*dpr(),4*dpr()]);
  overlayCtx.strokeStyle = "rgba(251,191,36,0.9)";
  overlayCtx.beginPath();
  if (hitV!=null){ const x=Math.round(hitV*dpr()); overlayCtx.moveTo(x,0); overlayCtx.lineTo(x, el.overlay.height); }
  if (hitH!=null){ const y=Math.round(hitH*dpr()); overlayCtx.moveTo(0,y); overlayCtx.lineTo(el.overlay.width, y); }
  overlayCtx.stroke(); overlayCtx.restore();
}

/* ====== Overlay drawing & selection ====== */
const HANDLE = 8; // px CSS

function drawOverlay(){
  overlayCtx.clearRect(0,0,el.overlay.width, el.overlay.height);
  drawGrid();
  for (const it of edits){
    if (it.page!==currentPageIndex) continue;
    drawItem(it, selectedIds.includes(it.id));
  }
  if (selectedIds.length>1){
    const gb = groupBox();
    if (gb){
      const gbd = toDev(gb);
      overlayCtx.lineWidth = 2*dpr();
      overlayCtx.strokeStyle = "rgba(59,130,246,0.95)";
      overlayCtx.strokeRect(gbd.x,gbd.y,gbd.w,gbd.h);
      drawHandles(gbd);
      drawRotateHandle(gbd);
    }
  }
}
function drawItem(it, selected){
  const r = it.rectCss, rd = toDev(r);
  overlayCtx.save();
  // rotation visualize (around center)
  const cx = rd.x + rd.w/2, cy = rd.y + rd.h/2;
  const rot = (it.rot||0);
  overlayCtx.translate(cx, cy);
  overlayCtx.rotate(rad(rot));
  overlayCtx.translate(-cx, -cy);

  if (it.type==='redact'){
    overlayCtx.fillStyle = it.color||'#000';
    overlayCtx.fillRect(rd.x, rd.y, rd.w, rd.h);
  } else if (it.type==='text'){
    overlayCtx.fillStyle = it.cover || '#fff';
    overlayCtx.fillRect(rd.x, rd.y, rd.w, rd.h);
    overlayCtx.fillStyle = it.color || '#000';
    const px = Math.max(10, (it.fontSize||12))*dpr();
    overlayCtx.font = (it.bold?'700 ':'') + px + 'px ' + (it.fontFamily||'Helvetica') + ', sans-serif';
    overlayCtx.textBaseline = 'top';
    const pad = 2*dpr();
    let x = rd.x + pad;
    if (it.align==='center') x = rd.x + (rd.w/2);
    if (it.align==='right')  x = rd.x + rd.w - pad;
    overlayCtx.save();
    if (it.align==='center') overlayCtx.textAlign='center';
    if (it.align==='right')  overlayCtx.textAlign='right';
    overlayCtx.fillText(it.text||'', x, rd.y + pad, rd.w - pad*2);
    overlayCtx.restore();
  } else if (it.type==='watermark'){
    // Draw semi-transparent watermark text
    const opacity = it.opacity || 0.3;
    overlayCtx.globalAlpha = opacity;
    const px = Math.max(16, (it.fontSize||48))*dpr();
    overlayCtx.font = (it.bold?'700 ':'') + px + 'px ' + (it.fontFamily||'Helvetica') + ', sans-serif';
    overlayCtx.fillStyle = it.color || '#888888';
    overlayCtx.textAlign = 'center';
    overlayCtx.textBaseline = 'middle';
    overlayCtx.fillText(it.text||'WATERMARK', cx, cy);
    overlayCtx.globalAlpha = 1.0;
  } else if (it.type==='image' && it.imageUrl){
    const img = getImg(it.imageUrl);
    if (img && img.complete) overlayCtx.drawImage(img, rd.x, rd.y, rd.w, rd.h);
    else {
      overlayCtx.fillStyle = "rgba(0,0,0,0.06)";
      overlayCtx.fillRect(rd.x, rd.y, rd.w, rd.h);
      overlayCtx.strokeStyle = "rgba(0,0,0,0.3)";
      overlayCtx.strokeRect(rd.x, rd.y, rd.w, rd.h);
    }
  }
  overlayCtx.restore();

  if (selected){
    overlayCtx.lineWidth = 2*dpr();
    overlayCtx.strokeStyle = "rgba(59,130,246,0.95)";
    overlayCtx.strokeRect(rd.x, rd.y, rd.w, rd.h);
    drawHandles(rd);
    drawRotateHandle(rd);
  }
}
function drawHandles(rd){
  const hs = HANDLE*dpr();
  const pts = handlePoints(rd);
  overlayCtx.fillStyle = "#fff";
  overlayCtx.strokeStyle = "rgba(59,130,246,1)";
  for (const p of pts){
    overlayCtx.fillRect(p.x - hs/2, p.y - hs/2, hs, hs);
    overlayCtx.strokeRect(p.x - hs/2, p.y - hs/2, hs, hs);
  }
}
function drawRotateHandle(rd){
  const r = 14*dpr();
  const top = { x: rd.x + rd.w/2, y: rd.y - 20*dpr() };
  overlayCtx.beginPath();
  overlayCtx.arc(top.x, top.y, r, 0, Math.PI*2);
  overlayCtx.fillStyle = "#fff";
  overlayCtx.fill();
  overlayCtx.lineWidth = 2*dpr();
  overlayCtx.strokeStyle = "rgba(59,130,246,1)";
  overlayCtx.stroke();
}
function handlePoints(rd){
  const x1=rd.x, y1=rd.y, x2=rd.x+rd.w, y2=rd.y+rd.h, xm=(x1+x2)/2, ym=(y1+y2)/2;
  return [
    {name:'nw', x:x1, y:y1},{name:'n', x:xm, y:y1},{name:'ne', x:x2, y:y1},
    {name:'e', x:x2, y:ym},{name:'se', x:x2, y:y2},{name:'s', x:xm, y:y2},
    {name:'sw', x:x1, y:y2},{name:'w', x:x1, y:ym}
  ];
}
function hitHandle(cssX, cssY, rd){
  const hs = HANDLE*dpr();
  const pts = handlePoints(rd);
  const dx = cssX*dpr(), dy = cssY*dpr();
  for (const p of pts){
    if (dx>=p.x-hs && dx<=p.x+hs && dy>=p.y-hs && dy<=p.y+hs) return p.name;
  }
  // rotate handle
  const rx = rd.x+rd.w/2, ry = rd.y - 20*dpr();
  const dist = Math.hypot(dx-rx, dy-ry);
  if (dist <= 14*dpr()+2) return 'rotate';
  return null;
}
function hitItemAt(cssX, cssY){
  for (let i=edits.length-1;i>=0;i--){
    const it = edits[i]; if (it.page!==currentPageIndex) continue;
    const r = it.rectCss;
    if (cssX>=r.x && cssX<=r.x+r.w && cssY>=r.y && cssY<=r.y+r.h) return it.id;
  }
  return null;
}
function groupBox(){
  if (!selectedIds.length) return null;
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for (const id of selectedIds){
    const it = edits.find(e=>e.id===id); if (!it || it.page!==currentPageIndex) continue;
    minX = Math.min(minX, it.rectCss.x); minY = Math.min(minY, it.rectCss.y);
    maxX = Math.max(maxX, it.rectCss.x+it.rectCss.w); maxY = Math.max(maxY, it.rectCss.y+it.rectCss.h);
  }
  if (minX===Infinity) return null;
  return { x:minX, y:minY, w:maxX-minX, h:maxY-minY };
}

/* ====== Image cache ====== */
const _img = new Map();
function getImg(url){ if (_img.has(url)) return _img.get(url); const im=new Image(); im.src=url; _img.set(url,im); return im; }

/* ====== Undo/Redo ====== */
function pushHistory(){ undoStack.push(deepClone(edits)); if (undoStack.length>200) undoStack.shift(); redoStack=[]; }
function undo(){ if (!undoStack.length) return; redoStack.push(deepClone(edits)); edits=undoStack.pop(); selectedIds=[]; drawOverlay(); }
function redo(){ if (!redoStack.length) return; undoStack.push(deepClone(edits)); edits=redoStack.pop(); selectedIds=[]; drawOverlay(); }

/* ====== Mouse & keyboard ====== */
let panning = false, panStart = null, scrollStart = null;
let spaceDown=false;

el.scroller.addEventListener('mousedown', (ev)=>{
  const rect = el.pdfCanvas.getBoundingClientRect();
  const overCanvas = ev.clientX>=rect.left && ev.clientX<=rect.right && ev.clientY>=rect.top && ev.clientY<=rect.bottom;
  if (!overCanvas) return;

  // Space = pan
  if (ev.button===0 && spaceDown){
    panning = true; panStart = {x:ev.clientX,y:ev.clientY}; scrollStart = {x:el.scroller.scrollLeft, y:el.scroller.scrollTop};
    return;
  }

  const cssX = ev.clientX-rect.left, cssY = ev.clientY-rect.top;

  if (el.tool.value==='select'){
    const id = hitItemAt(cssX, cssY);
    if (id!=null){
      const it = edits.find(e=>e.id===id);
      // selection logic
      if (!ev.shiftKey && !selectedIds.includes(id)) selectedIds=[id];
      if (ev.shiftKey && selectedIds.includes(id)){ selectedIds = selectedIds.filter(x=>x!==id); drawOverlay(); return; }
      if (ev.shiftKey && !selectedIds.includes(id)) selectedIds.push(id);

      const handle = hitHandle(cssX, cssY, toDev(it.rectCss));
      if (handle==='rotate'){ dragMode='rotate'; }
      else if (handle){ dragMode='resize'; resizeHandle=handle; }
      else { dragMode='move'; }
      dragStart = {x:cssX, y:cssY};
      startRects = selectedIds.map(id=>({id, rect: {...edits.find(e=>e.id===id).rectCss}, rot: edits.find(e=>e.id===id).rot||0 }));
      groupBoxAtStart = groupBox();
      return;
    } else {
      // marquee selection
      toolDragging = true; toolDragStart = {x:cssX, y:cssY};
      drawRubber(cssX, cssY);
      return;
    }
  }

  // creation with tools
  if (['editText','redact','image','find','watermark'].includes(el.tool.value)){
    toolDragging = true;
    toolDragStart = { x: cssX, y: cssY };
    drawRubber(cssX, cssY);
  }
});

window.addEventListener('mousemove', (ev)=>{
  if (panning){
    const dx = ev.clientX - panStart.x, dy = ev.clientY - panStart.y;
    el.scroller.scrollLeft = scrollStart.x - dx;
    el.scroller.scrollTop  = scrollStart.y - dy;
    return;
  }
  if (dragMode){
    const rect = el.pdfCanvas.getBoundingClientRect();
    const cssX = clamp(ev.clientX-rect.left,0,rect.width);
    const cssY = clamp(ev.clientY-rect.top,0,rect.height);
    const dx = cssX - dragStart.x, dy = cssY - dragStart.y;

    const guides = computeGuides(selectedIds);

    if (dragMode==='move'){
      let delta = {x:dx, y:dy};
      const gb0 = groupBoxAtStart;
      if (gb0){
        const movedGb = { x:gb0.x+delta.x, y:gb0.y+delta.y, w:gb0.w, h:gb0.h };
        const {rect:sn, hitV, hitH} = snapToGuides(movedGb, guides);
        delta.x += (sn.x - movedGb.x); delta.y += (sn.y - movedGb.y);
        drawOverlay(); drawGuideLines(hitV, hitH);
      }
      for (const s of startRects){
        const it = edits.find(e=>e.id===s.id);
        let r = {...s.rect};
        r.x = r.x + delta.x; r.y = r.y + delta.y;
        if (settings.snap) r = snapRect(r);
        it.rectCss = r;
      }
      drawOverlay();
    } else if (dragMode==='resize'){
      const applyResize = (r, handle, dx, dy)=>{
        const out = {...r}, minSize=8;
        switch(handle){
          case 'nw': out.x+=dx; out.y+=dy; out.w-=dx; out.h-=dy; break;
          case 'n':  out.y+=dy; out.h-=dy; break;
          case 'ne': out.y+=dy; out.w+=dx; out.h-=dy; break;
          case 'e':  out.w+=dx; break;
          case 'se': out.w+=dx; out.h+=dy; break;
          case 's':  out.h+=dy; break;
          case 'sw': out.x+=dx; out.w-=dx; out.h+=dy; break;
          case 'w':  out.x+=dx; out.w-=dx; break;
        }
        out.w=Math.max(minSize,out.w); out.h=Math.max(minSize,out.h);
        out.x=clamp(out.x,0,rect.width-out.w); out.y=clamp(out.y,0,rect.height-out.h);
        return settings.snap ? snapRect(out) : out;
      };
      if (selectedIds.length>1 && groupBoxAtStart){
        const gb = applyResize(groupBoxAtStart, resizeHandle, dx, dy);
        for (const s of startRects){
          const it = edits.find(e=>e.id===s.id);
          const rel = { x:(s.rect.x-groupBoxAtStart.x)/groupBoxAtStart.w, y:(s.rect.y-groupBoxAtStart.y)/groupBoxAtStart.h, w:s.rect.w/groupBoxAtStart.w, h:s.rect.h/groupBoxAtStart.h };
          it.rectCss = { x: gb.x + rel.x*gb.w, y: gb.y + rel.y*gb.h, w: rel.w*gb.w, h: rel.h*gb.h };
        }
      } else {
        const it = edits.find(e=>e.id===selectedIds[0]);
        it.rectCss = applyResize(startRects[0].rect, resizeHandle, dx, dy);
      }
      drawOverlay();
    } else if (dragMode==='rotate'){
      // item rotate by drag (free) ‚Äî still allowed, but buttons snap to 90¬∞
      const gb = groupBoxAtStart || edits.find(e=>e.id===selectedIds[0]).rectCss;
      const center = { x: gb.x + gb.w/2, y: gb.y + gb.h/2 };
      const a0 = Math.atan2(dragStart.y - center.y, dragStart.x - center.x);
      const a1 = Math.atan2((ev.clientY-rect.top) - center.y, (ev.clientX-rect.left) - center.x);
      let deg = (a1 - a0) * 180/Math.PI;
      for (const s of startRects){ const it = edits.find(e=>e.id===s.id); it.rot = (s.rot||0) + deg; }
      drawOverlay();
    }
    return;
  }

  if (toolDragging){
    const rect = el.pdfCanvas.getBoundingClientRect();
    const cssX = clamp(ev.clientX-rect.left, 0, rect.width);
    const cssY = clamp(ev.clientY-rect.top, 0, rect.height);
    drawRubber(cssX, cssY);
  }
});

window.addEventListener('mouseup', (ev)=>{
  if (panning){ panning=false; return; }
  if (dragMode){ pushHistory(); dragMode=null; startRects=null; resizeHandle=null; groupBoxAtStart=null; return; }

  if (toolDragging){
    const rect = el.pdfCanvas.getBoundingClientRect();
    const cssX = clamp(ev.clientX-rect.left,0,rect.width);
    const cssY = clamp(ev.clientY-rect.top,0,rect.height);
    const isClick = Math.abs(cssX-toolDragStart.x)<3 && Math.abs(cssY-toolDragStart.y)<3;
    let r = isClick ? { x:toolDragStart.x, y:toolDragStart.y, w:160, h:24 } : normalizeCssRect(toolDragStart,{x:cssX,y:cssY});
    if (settings.snap) r = snapRect(r);

    const tool = el.tool.value;
    if (tool==='redact'){
      pushHistory();
      const it = { id:nextId++, type:'redact', page:currentPageIndex, rectCss:r, color: el.redactColor.value, rot:0 };
      edits.push(it); selectedIds=[it.id];
    } else if (tool==='image'){
      const f = el.imgFile.files?.[0];
      if (!f){ alert('Choose an image first'); }
      else { pushHistory(); const url = URL.createObjectURL(f); const it={ id:nextId++, type:'image', page:currentPageIndex, rectCss:r, imageUrl:url, rot:0 }; edits.push(it); selectedIds=[it.id]; }
    } else if (tool==='editText'){
      const text = el.textValue.value||''; if (text.trim()){
        pushHistory();
        const it = {
          id:nextId++, type:'text', page:currentPageIndex, rectCss:r, rot:0,
          text, fontFamily: el.fontFamily.value, fontSize:parseInt(el.fontSize.value||'12',10),
          align: el.textAlign.value, bold: !!el.bold.checked, italic: !!el.italic.checked,
          color: el.textColor.value, cover: el.paintColor.value
        };
        edits.push(it); selectedIds=[it.id];
      }
    } else if (tool==='watermark'){
      const text = el.textValue.value||''; if (text.trim()){
        pushHistory();
        // Watermark: semi-transparent, rotated text centered on clicked area
        const it = {
          id:nextId++, type:'watermark', page:currentPageIndex, rectCss:r, rot:-45,
          text, fontFamily: el.fontFamily.value, fontSize:parseInt(el.fontSize.value||'48',10),
          align: 'center', bold: true, italic: false,
          color: el.textColor.value, opacity: 0.3
        };
        edits.push(it); selectedIds=[it.id];
      } else {
        alert('Enter watermark text first (e.g., "DRAFT", "CONFIDENTIAL")');
      }
    } else if (tool==='find'){
      const hit = findRuns.find(fr=>{
        const [x,y,w,h] = fr.bboxCss;
        return (toolDragStart.x>=x && toolDragStart.x<=x+w && toolDragStart.y>=y && toolDragStart.y<=y+h);
      });
      if (hit){
        pushHistory();
        const it = {
          id:nextId++, type:'text', page:currentPageIndex,
          rectCss: { x:hit.bboxCss[0], y:hit.bboxCss[1], w:hit.bboxCss[2], h:Math.max(22, hit.bboxCss[3]) }, rot:0,
          text: hit.text, fontFamily: el.fontFamily.value, fontSize: parseInt(el.fontSize.value||'12',10),
          align: 'left', bold:false, italic:false, color:'#000000', cover:'#ffffff'
        };
        edits.push(it); selectedIds=[it.id];
        el.textValue.value = hit.text;
      }
    }

    toolDragging=false; toolDragStart=null; drawOverlay();
  }
});

/* Keyboard helpers */
function isTyping(){
  const a=document.activeElement; if (!a) return false;
  const tag=a.tagName, type=a.getAttribute&&a.getAttribute('type');
  const texty=['text','number','color','search','email','url','tel','password'];
  return tag==='TEXTAREA'||tag==='SELECT'||(tag==='INPUT'&&texty.includes((type||'').toLowerCase()));
}
window.addEventListener('keydown', (e)=>{
  if (e.code==='Space'){ spaceDown=true; e.preventDefault(); }
  if (!isTyping()){
    if (e.key==='g'||e.key==='G'){ settings.showGrid=!settings.showGrid; el.showGrid.checked=settings.showGrid; drawOverlay(); }
    if (e.key==='s'||e.key==='S'){ settings.snap=!settings.snap; el.snap.checked=settings.snap; drawOverlay(); }
  }
});
window.addEventListener('keyup', (e)=>{ if (e.code==='Space'){ spaceDown=false; } });

/* Rotate ITEMS via buttons/shortcuts (lock to 90¬∞) */
function rotateSelection(direction){
  if (!selectedIds.length) return;
  const step = 90;
  pushHistory();
  for (const id of selectedIds){
    const it = edits.find(x => x.id === id);
    it.rot = ((it.rot || 0) + (direction > 0 ? step : -step)) % 360;
  }
  drawOverlay();
}
el.rotL && el.rotL.addEventListener('click', ()=>rotateSelection(-1));
el.rotR && el.rotR.addEventListener('click', ()=>rotateSelection(+1));
window.addEventListener('keydown', (e)=>{
  if (e.altKey && !e.ctrlKey && !e.metaKey && e.key.toLowerCase()==='r'){
    rotateSelection(e.shiftKey ? -1 : +1);
    e.preventDefault();
  }
});

/* Rotate PAGE live (90¬∞) */
function rotatePage(delta){
  if (!pageCount) return;
  const cur = (pageRotDelta[currentPageIndex] || 0);
  pageRotDelta[currentPageIndex] = ( (cur + delta) % 360 + 360 ) % 360;
  renderPage(currentPageIndex, true);
}
el.pageRotL && el.pageRotL.addEventListener('click', ()=>rotatePage(-90));
el.pageRotR && el.pageRotR.addEventListener('click', ()=>rotatePage(+90));
window.addEventListener('keydown', (e)=>{
  if (e.altKey && !e.ctrlKey && !e.metaKey && e.key.toLowerCase()==='p'){
    rotatePage(e.shiftKey ? -90 : +90);
    e.preventDefault();
  }
});

/* ====== Clipboard ====== */
let clipboard = [];
function copySelection(){ clipboard = selectedIds.map(id=>deepClone(edits.find(e=>e.id===id))); }
function pasteSelection(){
  if (!clipboard.length) return;
  pushHistory(); selectedIds=[];
  clipboard.forEach(ci=>{
    const clone = deepClone(ci);
    clone.id = nextId++; clone.page=currentPageIndex;
    clone.rectCss.x += 10; clone.rectCss.y += 10;
    edits.push(clone); selectedIds.push(clone.id);
  });
  drawOverlay();
}
function duplicateSelection(){ copySelection(); pasteSelection(); }

/* ====== Rubber-band (marquee / create preview) ====== */
function drawRubber(cssX, cssY){
  overlayCtx.clearRect(0,0,el.overlay.width, el.overlay.height);
  drawGrid();
  const r = normalizeCssRect(toolDragStart,{x:cssX,y:cssY});
  const rd = toDev(r);
  overlayCtx.lineWidth = 2*dpr();
  overlayCtx.setLineDash([6*dpr(),4*dpr()]);
  overlayCtx.strokeStyle = "rgba(59,130,246,0.9)";
  overlayCtx.strokeRect(rd.x,rd.y,rd.w,rd.h);
  overlayCtx.fillStyle = "rgba(59,130,246,0.15)";
  overlayCtx.fillRect(rd.x,rd.y,rd.w,rd.h);
}

/* ====== Zoom & wheel (higher max + cursor anchoring) ====== */
const MIN_Z = 0.1, MAX_Z = 20, ZF = 1.12;

el.zoomIn.onclick  = ()=>{ zoom = clamp(zoom*ZF, MIN_Z, MAX_Z); renderPage(currentPageIndex); };
el.zoomOut.onclick = ()=>{ zoom = clamp(zoom/ZF, MIN_Z, MAX_Z); renderPage(currentPageIndex); };
el.zoomReset.onclick = ()=>{ zoom = 1; renderPage(currentPageIndex, true); };

el.scroller.addEventListener('wheel', (e)=>{
  if (!e.ctrlKey) return;
  e.preventDefault();
  const rect = el.pdfCanvas.getBoundingClientRect();
  const old = zoom;
  const mx = (e.clientX-rect.left) + el.scroller.scrollLeft;
  const my = (e.clientY-rect.top)  + el.scroller.scrollTop;
  zoom = clamp(zoom*(e.deltaY<0? ZF : 1/ZF), MIN_Z, MAX_Z);
  const ratio = zoom/old;
  renderPage(currentPageIndex).then(()=>{
    el.scroller.scrollLeft = Math.max(0, (mx*ratio)-(e.clientX-rect.left));
    el.scroller.scrollTop  = Math.max(0, (my*ratio)-(e.clientY-rect.top));
  });
}, {passive:false});

window.addEventListener('resize', ()=>{ if (pdfDocRender) renderPage(currentPageIndex, false); });

/* ====== Page operations ====== */
async function reorderPages(order){
  const total = pdfDocWriter.getPageCount();
  const copies = await pdfDocWriter.copyPages(pdfDocWriter, [...Array(total).keys()]);
  const newDoc = await PDFLib.PDFDocument.create();
  for (const idx of order){ newDoc.addPage(copies[idx]); }
  const newBytes = await newDoc.save();
  await loadBoth(newBytes);
}
async function insertBlank(atIndex){
  pdfDocWriter.addPage(); // add at end
  const total = pdfDocWriter.getPageCount();
  const order = [...Array(total-1).keys()];
  order.splice(atIndex, 0, total-1);
  await reorderPages(order);
}
async function duplicatePage(idx){
  const [copied] = await pdfDocWriter.copyPages(pdfDocWriter, [idx]);
  pdfDocWriter.insertPage(idx+1, copied);
}
async function deletePage(idx){
  if (pdfDocWriter.getPageCount()<=1) return;
  pdfDocWriter.removePage(idx);
}
async function movePage(idx, dir){
  const total = pdfDocWriter.getPageCount();
  const to = clamp(idx+dir, 0, total-1);
  if (to===idx) return;
  const order = [...Array(total).keys()];
  const [p] = order.splice(idx,1);
  order.splice(to,0,p);
  await reorderPages(order);
  currentPageIndex = to;
}

el.pageInsertBefore.onclick = async()=>{ await insertBlank(currentPageIndex); await renderPage(currentPageIndex, true); };
el.pageInsertAfter.onclick  = async()=>{ await insertBlank(currentPageIndex+1); currentPageIndex++; await renderPage(currentPageIndex, true); };
el.pageDuplicate.onclick    = async()=>{ await duplicatePage(currentPageIndex); currentPageIndex++; await renderPage(currentPageIndex, true); };
el.pageDelete.onclick       = async()=>{ await deletePage(currentPageIndex); currentPageIndex = clamp(currentPageIndex-1,0,pdfDocWriter.getPageCount()-1); await renderPage(currentPageIndex, true); };
el.pageUp.onclick           = async()=>{ await movePage(currentPageIndex,-1); await renderPage(currentPageIndex, true); };
el.pageDown.onclick         = async()=>{ await movePage(currentPageIndex, 1); await renderPage(currentPageIndex, true); };

/* ====== Apply staged items into PDF ====== */
function hexToRgb(hex){
  const h = hex.replace('#',''); const n = parseInt(h,16);
  const r = (h.length===3)?((n>>8)&0xF)*17:(n>>16)&0xFF;
  const g = (h.length===3)?((n>>4)&0xF)*17:(n>>8)&0xFF;
  const b = (h.length===3)?(n&0xF)*17:(n&0xFF);
  return PDFLib.rgb(r/255,g/255,b/255);
}

async function applyEditsToPdf(){
  if (!pdfDocWriter) return;

  if (!edits.length){
    const ok = confirm('No staged items to apply. Continue anyway?');
    if (!ok) return;
  } else {
    const ok = confirm(`Apply ${edits.length} staged item${edits.length>1?'s':''} into the PDF?\nThis will embed text/images/redactions on their pages.`);
    if (!ok) return;
  }

  // embed custom font if chosen
  if (customFontBytes && !customFontEmbedded){
    try{ customFontEmbedded = await pdfDocWriter.embedFont(customFontBytes); }catch(_){}
  }

  for (const it of edits){
    const page = pdfDocWriter.getPage(it.page);
    const r = cssRectToPdf(it.rectCss);
    const rot = PDFLib.degrees(it.rot||0);

    if (it.type === 'redact'){
      page.drawRectangle({ x:r.x, y:r.y, width:r.w, height:r.h, color: hexToRgb(it.color||'#000000'), rotate:rot });
    }
    else if (it.type === 'image' && it.imageUrl){
      const blob = await fetch(it.imageUrl).then(r=>r.blob());
      const buf = await blob.arrayBuffer();
      const img = blob.type.includes('png') ? await pdfDocWriter.embedPng(buf) : await pdfDocWriter.embedJpg(buf);
      const s = Math.min(r.w/img.width, r.h/img.height);
      const w = img.width*s, h = img.height*s;
      page.drawImage(img, { x:r.x, y:r.y, width:w, height:h, rotate:rot });
    }
    else if (it.type === 'text'){
      // cover background first
      page.drawRectangle({ x:r.x, y:r.y, width:r.w, height:r.h, color: hexToRgb(it.cover||'#FFFFFF'), rotate:rot });

      // choose font (supports standard, custom, and bundled fonts)
      let font = null;
      if (it.fontFamily==='Custom' && customFontEmbedded) {
        font = customFontEmbedded;
      } else if (bundledFonts && bundledFonts[it.fontFamily]) {
        // Load bundled font
        const fontBytes = await loadBundledFont(it.fontFamily);
        if (fontBytes) {
          font = await pdfDocWriter.embedFont(fontBytes);
        }
      }
      if (!font) {
        const S = PDFLib.StandardFonts;
        const map = { Helvetica:S.Helvetica, TimesRoman:S.TimesRoman, Courier:S.Courier };
        font = await pdfDocWriter.embedFont(map[it.fontFamily]||S.Helvetica);
      }

      const size = clamp(parseInt(it.fontSize||'12',10), 6, 120);
      const color = hexToRgb(it.color||'#000000');
      const text = it.text||'';

      // approximate alignment
      const width = font.widthOfTextAtSize(text, size);
      let x = r.x + 2, y = r.y + 2;
      if (it.align==='center') x = r.x + (r.w/2) - width/2;
      if (it.align==='right')  x = r.x + r.w - 2 - width;

      // faux bold/italic for preview parity
      const strokes = it.bold ? [{dx:0,dy:0},{dx:0.3,dy:0}] : [{dx:0,dy:0}];
      for (const d of strokes){
        page.drawText(text, { x:x+d.dx, y:y+d.dy, size, font, color, rotate:rot, maxWidth:r.w-4 });
      }
      if (it.italic){
        page.drawText(text, { x:x+0.5, y:y, size, font, color, rotate:PDFLib.degrees((it.rot||0)-8), maxWidth:r.w-4 });
      }
    }
    else if (it.type === 'watermark'){
      // Watermark: semi-transparent text with rotation
      let font = null;
      if (it.fontFamily==='Custom' && customFontEmbedded) {
        font = customFontEmbedded;
      } else if (bundledFonts && bundledFonts[it.fontFamily]) {
        const fontBytes = await loadBundledFont(it.fontFamily);
        if (fontBytes) {
          font = await pdfDocWriter.embedFont(fontBytes);
        }
      }
      if (!font) {
        const S = PDFLib.StandardFonts;
        const map = { Helvetica:S.Helvetica, TimesRoman:S.TimesRoman, Courier:S.Courier };
        font = await pdfDocWriter.embedFont(map[it.fontFamily]||S.Helvetica);
      }

      const size = clamp(parseInt(it.fontSize||'48',10), 12, 200);
      const opacity = it.opacity || 0.3;
      const color = hexToRgb(it.color||'#888888');
      const text = it.text||'WATERMARK';

      // Center text in the box
      const width = font.widthOfTextAtSize(text, size);
      const cx = r.x + r.w/2;
      const cy = r.y + r.h/2;

      page.drawText(text, {
        x: cx - width/2,
        y: cy - size/2,
        size,
        font,
        color,
        rotate: rot,
        opacity: opacity
      });
    }
  }

  // NEW: Commit page rotations (apply after drawing so marks rotate with the page)
  for (let i=0; i<pdfDocWriter.getPageCount(); i++){
    const delta = (pageRotDelta[i] || 0);
    if (delta){
      const p = pdfDocWriter.getPage(i);
      const base = (p.getRotation()?.angle) || 0;
      p.setRotation(PDFLib.degrees((base + delta) % 360));
    }
  }

  // clear staged and refresh
  edits=[]; selectedIds=[];
  const newBytes = await pdfDocWriter.save();
  await loadBoth(newBytes);

  // reset visual deltas now that rotations are baked in
  pageRotDelta = new Array(pageCount).fill(0);
}

/* ====== Save / Download ====== */
el.apply.onclick = ()=>applyEditsToPdf();

el.download.onclick = async ()=>{
  await applyEditsToPdf();
  const bytes = await pdfDocWriter.save();
  const blob = new Blob([bytes], {type:'application/pdf'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='edited.pdf'; a.click();
};

el.save.onclick = async ()=>{
  await applyEditsToPdf();
  const bytes = await pdfDocWriter.save();
  const blob = new Blob([bytes], {type:'application/pdf'});
  const form = new FormData();
  form.append('file', blob, 'edited.pdf');
  form.append('name', (el.versionName.value||'edited').trim());
  form.append('keep', (el.keepN.value||'5'));
  const res = await fetch('api/save.php', { method:'POST', body: form });
  if (!res.ok){ alert('Save failed'); return; }
  const json = await res.json();
  alert(json?.ok ? ('Saved: ' + json.path) : 'Save failed');
};

/* ====== UI wiring & context-aware inputs ====== */
el.undo.onclick=()=>undo();
el.redo.onclick=()=>redo();
el.duplicate.onclick=()=>duplicateSelection();
el.del.onclick=()=>{ if (!selectedIds.length) return; pushHistory(); edits = edits.filter(e=>!selectedIds.includes(e.id)); selectedIds=[]; drawOverlay(); };

el.snap.onchange=()=>{ settings.snap = el.snap.checked; };
el.gridSize.onchange=()=>{ settings.grid = clamp(parseInt(el.gridSize.value||'8',10), 2, 64); drawOverlay(); };
el.showGrid.onchange=()=>{ settings.showGrid = el.showGrid.checked; drawOverlay(); };

el.customFont.onchange = async (e)=>{
  const f = e.target.files?.[0]; if (!f) return;
  customFontBytes = new Uint8Array(await f.arrayBuffer());
  customFontEmbedded = null;
  alert('Custom font loaded. Choose "Custom TTF" in Font to use it.');
};

function contextualizeUI(){
  const tool = el.tool.value;
  // Show/hide tool-specific sections
  const textSettings = document.getElementById('textSettings');
  const redactSettings = document.getElementById('redactSettings');
  const imageSettings = document.getElementById('imageSettings');
  const ocrSettings = document.getElementById('ocrSettings');
  const findSettings = document.getElementById('findSettings');
  
  if (textSettings) textSettings.style.display = ['editText', 'watermark'].includes(tool) ? 'block' : 'none';
  if (redactSettings) redactSettings.style.display = tool === 'redact' ? 'block' : 'none';
  if (imageSettings) imageSettings.style.display = tool === 'image' ? 'block' : 'none';
  if (ocrSettings) ocrSettings.style.display = tool === 'ocr' ? 'block' : 'none';
  if (findSettings) findSettings.style.display = tool === 'find' ? 'block' : 'none';
  
  // Show custom font input when Custom is selected
  const customFontInput = document.getElementById('customFont');
  if (customFontInput) {
    customFontInput.style.display = el.fontFamily.value === 'Custom' ? 'block' : 'none';
  }
}
el.tool.addEventListener('change', contextualizeUI);
el.fontFamily.addEventListener('change', contextualizeUI);

/* ====== Find navigation ====== */
el.findNext.onclick=()=>{
  const q = (el.findInput.value||'').toLowerCase();
  const hits = findRuns.map((r,i)=>({i,hit:r.text.toLowerCase().includes(q)})).filter(x=>x.hit);
  if (!hits.length){ el.findCount.textContent='0 matches'; return; }
  const order = hits.map(h=>h.i).sort((a,b)=>a-b);
  const pos = order.indexOf(findIndex);
  const next = order[(pos+1) % order.length];
  findIndex = next;

  overlayCtx.clearRect(0,0,el.overlay.width, el.overlay.height);
  drawGrid();
  const fr = findRuns[findIndex];
  const rd = toDev({x:fr.bboxCss[0], y:fr.bboxCss[1], w:fr.bboxCss[2], h:fr.bboxCss[3]});
  overlayCtx.lineWidth = 3*dpr(); overlayCtx.strokeStyle="rgba(34,197,94,0.95)";
  overlayCtx.strokeRect(rd.x, rd.y, rd.w, rd.h);
  el.findCount.textContent = `${order.indexOf(findIndex)+1}/${order.length}`;
};

/* ====== Loading/Progress indicator ====== */
const loadingEl = document.getElementById('loadingIndicator');
const loadingText = document.getElementById('loadingText');

function showLoading(text = 'Loading PDF...') {
  loadingText.textContent = text;
  loadingEl.classList.add('visible');
}
function hideLoading() {
  loadingEl.classList.remove('visible');
}
function showError(message, duration = 5000) {
  const toast = document.createElement('div');
  toast.className = 'error-toast';
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(() => toast.remove(), duration);
}
function showWarning(message, duration = 5000) {
  const toast = document.createElement('div');
  toast.className = 'warning-toast';
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(() => toast.remove(), duration);
}

/* ====== Drag and Drop support ====== */
const dropZone = document.getElementById('dropZone');

async function handlePdfFile(file) {
  if (!file) return;
  
  // Validate file type
  if (!file.type.includes('pdf') && !file.name.toLowerCase().endsWith('.pdf')) {
    showError('Please select a valid PDF file.');
    return;
  }
  
  // Warn about large files (but still process them)
  const MAX_SIZE = 50 * 1024 * 1024; // 50MB
  if (file.size > MAX_SIZE) {
    showWarning('Large file detected. Processing may take a while.');
  }
  
  try {
    showLoading('Loading PDF...');
    const buf = await file.arrayBuffer();
    edits = []; undoStack = []; redoStack = []; selectedIds = [];
    await loadBoth(buf);
    hideLoading();
  } catch (err) {
    hideLoading();
    console.error('Failed to load PDF:', err);
    showError('Failed to load PDF: ' + (err.message || 'Unknown error'));
  }
}

// Drag events
dropZone.addEventListener('dragenter', (e) => {
  e.preventDefault();
  dropZone.classList.add('drag-over');
});
dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropZone.classList.add('drag-over');
});
dropZone.addEventListener('dragleave', (e) => {
  e.preventDefault();
  // Only remove class if leaving the dropzone entirely
  if (!dropZone.contains(e.relatedTarget)) {
    dropZone.classList.remove('drag-over');
  }
});
dropZone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dropZone.classList.remove('drag-over');
  
  const files = e.dataTransfer?.files;
  if (files && files.length > 0) {
    await handlePdfFile(files[0]);
  }
});

// Update the file input handler to use the new function
el.file.onchange = async (e) => {
  const f = e.target.files?.[0];
  await handlePdfFile(f);
};

/* ====== Boot ====== */
el.snap.checked = settings.snap;
el.gridSize.value = settings.grid;
el.showGrid.checked = settings.showGrid;
contextualizeUI();

/* ====== Sidebar toggle for mobile ====== */
const sidebarToggle = document.getElementById('sidebarToggle');
const sidebar = document.getElementById('sidebar');
if (sidebarToggle && sidebar) {
  sidebarToggle.onclick = () => sidebar.classList.toggle('open');
}

/* ====== Bundled font loading ====== */
const bundledFonts = {
  'Roboto': '/fonts/Roboto-Regular.ttf',
  'Roboto-Bold': '/fonts/Roboto-Bold.ttf',
  'Roboto-Italic': '/fonts/Roboto-Italic.ttf',
  'OpenSans': '/fonts/OpenSans-Regular.ttf',
  'OpenSans-Bold': '/fonts/OpenSans-Bold.ttf',
  'OpenSans-Italic': '/fonts/OpenSans-Italic.ttf',
  'Lato': '/fonts/Lato-Regular.ttf',
  'Lato-Bold': '/fonts/Lato-Bold.ttf',
  'Lato-Italic': '/fonts/Lato-Italic.ttf',
  'Merriweather': '/fonts/Merriweather-Regular.ttf',
  'Merriweather-Bold': '/fonts/Merriweather-Bold.ttf',
  'SourceSansPro': '/fonts/SourceSansPro-Regular.ttf',
  'SourceSansPro-Bold': '/fonts/SourceSansPro-Bold.ttf',
  'SourceCodePro': '/fonts/SourceCodePro-Regular.ttf',
  'SourceCodePro-Bold': '/fonts/SourceCodePro-Bold.ttf'
};
const loadedFonts = new Map(); // Cache loaded fonts

async function loadBundledFont(fontName) {
  if (loadedFonts.has(fontName)) return loadedFonts.get(fontName);
  const path = bundledFonts[fontName];
  if (!path) return null;
  try {
    const resp = await fetch(path);
    if (!resp.ok) throw new Error('Font not found');
    const bytes = new Uint8Array(await resp.arrayBuffer());
    loadedFonts.set(fontName, bytes);
    return bytes;
  } catch (e) {
    console.warn('Failed to load font:', fontName, e);
    return null;
  }
}

/* ====== OCR functionality ====== */
let ocrWorker = null;

function showSuccess(message, duration = 4000) {
  const toast = document.createElement('div');
  toast.className = 'success-toast';
  toast.textContent = message;
  document.body.appendChild(toast);
  setTimeout(() => toast.remove(), duration);
}

async function initOCR() {
  if (typeof Tesseract === 'undefined') {
    showError('OCR not available. Tesseract.js failed to load.');
    return null;
  }
  const lang = document.getElementById('ocrLang')?.value || 'eng';
  const progress = document.getElementById('ocrProgress');
  const progressFill = document.getElementById('ocrProgressFill');
  const progressText = document.getElementById('ocrProgressText');
  
  if (progress) progress.classList.add('visible');
  if (progressText) progressText.textContent = 'Initializing OCR...';
  
  try {
    ocrWorker = await Tesseract.createWorker({
      langs: lang,
      oem: 1,
      logger: m => {
        if (m.status && progressText) {
          progressText.textContent = m.status;
        }
        if (m.progress && progressFill) {
          progressFill.style.width = Math.round(m.progress * 100) + '%';
        }
      }
    });
    return ocrWorker;
  } catch (e) {
    const errorMsg = e?.message || String(e) || 'Unknown initialization error';
    showError('Failed to initialize OCR: ' + errorMsg);
    if (progress) progress.classList.remove('visible');
    ocrWorker = null;
    return null;
  }
}

async function performOCR(imageData) {
  const progress = document.getElementById('ocrProgress');
  const progressFill = document.getElementById('ocrProgressFill');
  const progressText = document.getElementById('ocrProgressText');
  
  try {
    if (!ocrWorker) {
      ocrWorker = await initOCR();
      if (!ocrWorker) return null;
    }
    
    if (progressText) progressText.textContent = 'Recognizing text...';
    const result = await ocrWorker.recognize(imageData);
    
    if (progress) progress.classList.remove('visible');
    return result.data;
  } catch (e) {
    const errorMsg = e?.message || String(e) || 'Unknown error';
    showError('OCR failed: ' + errorMsg);
    if (progress) progress.classList.remove('visible');
    // Reset worker on error to prevent reusing a broken worker
    try {
      if (ocrWorker) await ocrWorker.terminate();
    } catch (termErr) { /* ignore termination errors */ }
    ocrWorker = null;
    return null;
  }
}

// OCR current page button
const ocrPageBtn = document.getElementById('ocrPage');
if (ocrPageBtn) {
  ocrPageBtn.onclick = async () => {
    if (!pdfDocRender) {
      showError('Please load a PDF first');
      return;
    }
    
    showLoading('Preparing page for OCR...');
    
    // Render current page to canvas at higher resolution for better OCR
    const page = await pdfDocRender.getPage(currentPageIndex + 1);
    const scale = 2; // Higher resolution for better OCR
    const vp = page.getViewport({ scale });
    
    const canvas = document.createElement('canvas');
    canvas.width = vp.width;
    canvas.height = vp.height;
    const ctx = canvas.getContext('2d');
    
    await page.render({ canvasContext: ctx, viewport: vp }).promise;
    hideLoading();
    
    const ocrResult = await performOCR(canvas);
    if (ocrResult && ocrResult.text) {
      // Show OCR result in a modal or copy to clipboard
      const text = ocrResult.text.trim();
      if (text) {
        try {
          await navigator.clipboard.writeText(text);
          showSuccess(`OCR complete! ${ocrResult.words?.length || 0} words copied to clipboard.`);
        } catch (e) {
          // Fallback: show in alert
          alert('OCR Result:\n\n' + text);
        }
      } else {
        showWarning('No text detected on this page.');
      }
    }
  };
}

// OCR selection button - performs OCR on currently selected area
let ocrSelectionMode = false;
const ocrSelBtn = document.getElementById('ocrSelection');
if (ocrSelBtn) {
  ocrSelBtn.onclick = async () => {
    if (!pdfDocRender) {
      showError('Please load a PDF first');
      return;
    }
    
    // Check if there's a selection (selectedIds has items)
    if (selectedIds.length === 0) {
      // No selection - prompt user to draw one
      showWarning('Draw a selection box on the page first, then click OCR Selection again.');
      el.tool.value = 'redact'; // Switch to redact tool for drawing boxes
      contextualizeUI();
      ocrSelectionMode = true;
      return;
    }
    
    // Get the bounding box of selected items
    const gb = groupBox();
    if (!gb) {
      showError('Could not determine selection area');
      return;
    }
    
    showLoading('Preparing selection for OCR...');
    
    // Render current page to canvas at higher resolution
    const page = await pdfDocRender.getPage(currentPageIndex + 1);
    const scale = 2;
    const vp = page.getViewport({ scale });
    
    const canvas = document.createElement('canvas');
    canvas.width = vp.width;
    canvas.height = vp.height;
    const ctx = canvas.getContext('2d');
    
    await page.render({ canvasContext: ctx, viewport: vp }).promise;
    
    // Crop to selection area
    const cropCanvas = document.createElement('canvas');
    const cropX = Math.round(gb.x * scale * dpr());
    const cropY = Math.round(gb.y * scale * dpr());
    const cropW = Math.round(gb.w * scale * dpr());
    const cropH = Math.round(gb.h * scale * dpr());
    
    cropCanvas.width = cropW;
    cropCanvas.height = cropH;
    const cropCtx = cropCanvas.getContext('2d');
    cropCtx.drawImage(canvas, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);
    
    hideLoading();
    
    const ocrResult = await performOCR(cropCanvas);
    if (ocrResult && ocrResult.text) {
      const text = ocrResult.text.trim();
      if (text) {
        try {
          await navigator.clipboard.writeText(text);
          showSuccess(`OCR complete! Text copied to clipboard.`);
        } catch (e) {
          alert('OCR Result:\n\n' + text);
        }
      } else {
        showWarning('No text detected in the selected area.');
      }
    }
    
    ocrSelectionMode = false;
  };
}
</script>

<!-- Shape drawing tools: Box, Line, Arrow, Dimension -->
<script src="/app/addons-draw.js"></script>

</body>
</html>
